{
  "report" : "Web App and Infrastructure and Mobile Report.pdf",
"finding_dict": {
"sr-102-001" : {
  "identifier": "sr-102-001",
  "title": "reflected cross-site scripting (xss)",
  "risk": "Medium",
  "status": "Open",
  "description": "the website was vulnerable to reflected, or non-persistent, cross-site scripting (xss) attacks. this type of vulnerability occurs when data provided by a web client is used immediately by server-side scripts to generate a page of results for the user. if unvalidated user-supplied data is included in the resulting page without full and proper html escaping, client-side executable code may be injected into the dynamic page.",
  "recommendation": "reliable avoidance of cross-site scripting vulnerabilities should consist of two stages - input validation and output encoding. input validation involves the application rejecting any characters which are invalid for the field in question, preferably by whitelisting a limited set of characters (in a telephone number field, for example, the whitelisted characters could be 0-9, parentheses, and hyphens). this strategy can also help in mitigating other flaws which stem from a failure to sanitise input, such as sql or http header injection attacks. output encoding requires the encoding of all special characters (such as those used in html and javascript) in potentially malicious data. this is generally done directly before display by web applications (or client-side script), and many programming languages have built-in functions or libraries which provide this encoding (also called quoting or escaping in this context). note that the correct encoding of the output depends on the location that the data is to be used within the response. in the case of it being within the main body of the document, html entities must be encoded. if the input is to be used within a script inside of a string, the quotes used for that string must be escaped. in general, it is important to ensure that it is not possible for the data to include whatever sequence is used to demark the end of that data and the beginning of something else. the application should be reviewed and, if necessary, modified, to handle malicious data properly. the specific instances identified in this finding should be addressed, and the application code base should also be examined for any similar issues which may exist.",
  "affects": "IP address: 10.x.x.x; DNS name: www.testorg-client.co.uk; Page: vulnerablepage.html and vulnerablepage2.html; Parameter(s): email_address"
},
"sr-102-002" : {
  "identifier": "sr-102-002",
  "title": "uploaded file types were not restricted",
  "risk": "medium",
  "status": "open",
  "description": "the web application allowed any type of file to be uploaded, although anti-virus scanning was in place and would detect any attempt to upload malware. the lack of restrictions could allow an attacker to upload an otherwise legitimate file containing malicious code. for example, an attacker might be able target the server itself, by uploading a web shell that would provide the attacker with the capability to run commands on the server and access the file system with the full privileges of the web server process. as a proof of concept, a .php file was uploaded containing malicious code. if triggered, this would have given the attacker command line execution. figure 1: uploaded php file although it was possible to upload a file containing malicious code, access to the directory used to store the uploaded files required an active directory account. accordingly, the risk associated with this issue has been lowered to medium.",
  "recommendation": "the file types allowed to be uploaded should be restricted to only those that are necessary for business functionality. u the application should perform filtering and content checking on any files which are uploaded to the server. files should be thoroughly scanned and validated before being made available to other users. if in doubt, the file should be discarded. note that the effectiveness of content-checking controls should not be wholly relied upon, and that they will only provide benefit if the anti-virus and malware signatures are regularly updated. it is also recommended that some consideration should be given to storing uploaded files in a database, rather than on the file system. this would significantly reduce the risk associated with the file upload facility, but it is recognised that this might require extensive changes to the current application design affects: ip address dns name 192.1.1.111 www.testorg-client.co.uk",
  "affects": "IP address: 192.1.1.111, DNS name: www.testorg-client.co.uk"
},
"sr-102-003" : {
  "identifier": "sr-102-003",
  "title": "HTTP Header Discloses Internal IP Address",
  "risk": "low",
  "status": "open",
  "description": "It was possible to determine an internal IP address by sending a crafted request to the application. An attacker could use this information to gain a greater understanding of the internal network and tailor further attacks.",
  "recommendation": "On IIS version 7 and above, this issue can be addressed by setting the IIS AlternateHostName property (as described at the www.iis.net link below). This allows the specified hostname to be used in place of the internal IP address in redirection responses. Testing should be performed to ensure that this does not adversely affect any legitimate redirection functionality in the application.  1, 2",
  "affects": "IP Address DNS Name 192.1.1.111 www.testorg-client.co.uk"
},
"sr-102-004" : {
  "identifier": "sr-102-004",
  "title": "username enumeration via login function",
  "risk": "low",
  "status": "open",
  "description": "it was possible to enumerate users of the website through the login mechanism. this provided different responses to failed login attempts depending on whether or not the supplied username was valid. an attacker could potentially use this difference in behaviour to compile a list of valid usernames which could then be used as the basis for further attacks against the application. when an authentication attempt was made with a valid username but an incorrect password, the application returned ",
  "recommendation": "the login mechanism should be modified to return the same error message for a failed login attempt regardless of whether or not the supplied username is valid.",
  "affects": "ip address dns name 192.1.1.111 www.testorg-client.co.uk"
},
"sr-102-005" : {
  "identifier": "sr-102-005",
  "title": "Verbose error messages",
  "risk": "low",
  "status": "open",
  "description": "the web application was configured to display detailed error messages when an application exception was generated. printing debugging information in the form of a stack trace associated with an error can leak information about the internal structure of the application which could potentially lead to the discovery or classification of additional vulnerabilities.",
  "recommendation": "application errors should be handled gracefully, and unnecessary technical information should not be presented to users. applications should return suitably generic but user friendly error messages that do not disclose sensitive information.",
  "affects": "ip address dns name 192.1.1.111 www.testorg-client.co.uk"
},
"sr-102-006" : {
  "identifier": "sr-102-006",
  "title": "unsupported operating system",
  "risk": "high",
  "status": "open",
  "description": "windows server 2008 was found to be installed on the affected host. this software reached its end of life date in january 2020 and is no longer supported by microsoft. it may contain security vulnerabilities that will never be addressed by microsoft. figure 5: windows server 2008 login page in addition, the length of time this issue has remained unaddressed may indicate a gap in the software patching process.",
  "recommendation": "this software should be upgraded to the latest stable, secure and supported version of the software. an investigation into the software patching policy and procedures and ensure that updates are applied to all software installations, including third party applications, on a regular basis. the software upgrade should take into account hardware requirements if necessary.",
  "affects": "ip address dns name 192.1.1.111 www.testorg-client.co.uk"
},
"sr-102-007" : {
  "identifier": "sr-102-007",
  "title": "Certificate signed with MD5",
  "risk": "low",
  "status": "open",
  "description": "The SSL/TLS service on the affected hosts listed below presented an SSL certificate whose digital signature relied on the MD5 hashing algorithm. MD5 is cryptographically weak and is vulnerable to collision attacks (in which input can be crafted that will result in a hash identical to some other input). This principle can be used to generate spoofed SSL certificates which will be accepted as valid by browsers. This would allow an attacker to create their own certificate with the same signature as the genuine one, they could then use this to masquerade as the affected service as the spoofed certificate would be indistinguishable from the genuine one. Whilst this attack has been shown to be possible, it requires a significant amount of computing effort to produce the false certificate. Nevertheless, major browser vendors have already implemented updates which treat MD5 based certificates as insecure and issue warnings to users (see references below). Figure 6: Screenshot with signed with MD5 hash",
  "recommendation": "Request that the Certificate Authority reissue the certificate using a stronger hashing algorithm such as SHA-256.",
  "affects": "IP address DNS name 192.1.1.111 www.testorg-client.co.uk"
},
"sr-102-008" : {
  "identifier": "sr-102-008",
  "title": "closed udp ports discovered",
  "risk": "informational",
  "status": "open",
  "description": "port scans revealed the presence of closed udp ports, which can be useful in fingerprinting systems and greatly speed up an attacker\\u0026#39;s network scans. open udp ports do not have to send an acknowledgement in response to a request, and closed ports are not even required to send an error packet. however, some devices do send an icmp port unreachable packet when a packet is sent to a closed udp port. thus it may be possible to determine if a port is not open. closed udp ports can be useful for fingerprinting remote systems, and increase the accuracy of scan results. unused ports allowed through the firewall also provide an attacker with the ability to bind new services to them if a compromise has occurred. this can enable an attacker to gain extended access or to bounce packets to deeper layers within the architecture. furthermore, closed ports can reveal the administrative habits and history of the device, potentially enabling identification of services that have been active in the past and that could be accessible in the future.",
  "recommendation": "all attempts to access unused udp ports should be silently dropped by filtering devices. this can be achieved through blocking the relevant port on the firewall device.",
  "affects": "ip address dns name 192.1.1.111 www.testorg-client.co.uk 4.3 phase 3 -mobile application and web service assessment"
},
"sr-102-009" : {
  "identifier": "sr-102-009",
  "title": "Hard-coded Credentials",
  "risk": "hard-coded credentials",
  "status": "open",
  "description": "During testing, it was discovered that the application communicated with the web service using HTTP basic authentication. When HTTP basic authentication is used, the credentials are sent to the server in a Base64 encoded format. No cookie or session is upheld, as the authentication header (the Base64 string) is sent with each request to authenticate the application\\u2019s request to the server. The authentication token was the same for every request sent to the web service, suggesting that authentication was on an application level, and users were only authenticated locally. The Base64 encoded authentication token was decoded, as per below: Authentication token: abcdefghijklmnopqrstuvwftjtratvhxwv5asdrv Decoded from Base64: svc-sitesbcert:r!m123456qy\\u00dfzh4u The consultant then inspected the application binary, and discovered that these credentials were hard-coded into the application. If an attacker is able to gain access to the application binary, they would be able to recover the clear-text credentials used to communicate with the web service. Additionally, any attacker performing a successful man in the middle attack could sniff the credentials from the HTTP session. Once the attacker has successfully obtained the credentials, they would then be able to communicate directly with the web service, and carry out transactions with the same permissions as the application.",
  "recommendation": "Credentials should not be hard-coded into the application as these can easily be recovered by an attacker with access to the binary. If HTTP basic authentication is used, it should be used in conjunction with properly configured TLS/SSL. In addition to authentication, each user of the application should be identified to the web service using an authorisation token, which should be checked to ensure the user is authorised to carry out the requested action. This ensures that even if an attacker gains access to the web service authentication credentials, they would not be authorised to carry out any transactions without an authorisation token.",
  "affects": "\"abc 123.ipa\""
},
"sr-102-010" : {
  "identifier": "sr-102-010",
  "title": "SSL Certificate Checking Disabled",
  "risk": "Medium",
  "status": "Open",
  "description": "The application was found to ignore the in-built iOS SSL certificate checking functionality. This meant that it was possible for an attacker to perform a man-in-the-middle attack by presenting their own SSL certificate, and thus nullifies the use of SSL. In iOS, when connecting to an HTTPS website, if the common name field in the SSL certificate presented by the server does not match the host and domain component of the URL, the warning message \"cannot verify server identity\" is automatically displayed. The application should handle this case gracefully with NSURLConnection's \"connection: didFailWithError\" method. It was discovered that the application disabled the default certificate checking, by using the NSURLConnectionContinueWithoutCredentialForAuthenticationChallenge method. This may have been set by the developer to aid in debugging, or for use when the SSL certificate is self-signed or unknown. Certificate checking should never be disabled in a production environment, and the server should always present a valid certificate from a trusted CA.",
  "recommendation": "In a production environment, SSL certificate checking should be enforced to ensure the confidentiality and integrity of users' information. The application should handle certificate mismatch errors, using the NSURLConnection \"connection:didFailWithError\" method, and deny connections where there is a certificate mismatch. For a defence in depth strategy, consider the use of certificate pinning to allow only connections using a specific certificate or signed by a specific CA.",
  "affects": "\"abc 123.ipa\""
},
"sr-102-011" : {
  "identifier": "sr-102-011",
  "title": "no jailbreak detection",
  "risk": "medium",
  "status": "open",
  "description": "allowing the application to be installed or run on a jailbroken device exposes the application to trivial and sophisticated attacks, and to reverse engineering. ios jailbreaking refers to the process of removing the limitations imposed by apple on devices (such as the iphone, ipod touch and ipad) through the use of exploit tools. jailbreaking enables users to gain complete control of the ios operating system, allowing them to download additional applications which are not available via the apple store, and to use the device freely with any carrier. jailbreaking an ios device can be a trivial process which takes around five or ten minutes; this process can be undone by reinstalling ios (in around thirty minutes). however, jailbreaking an ios device in this way has security implications, because untrusted code can be installed, security protections can be removed, and installed applications and data can be tampered with (as well as an increased potential for malware on the device). in short, all ios protection mechanisms can be bypassed if a device has been jailbroken, and as such there can be no inherent guarantee of a secure platform, and any data at rest can potentially be decrypted. additionally, jailbreaking can be used on a stolen device in order to help retrieve data from it and access installed applications and services. if the device has no passcode, or a weak passcode set, then the device could be jailbroken to break the security protections included by default.",
  "recommendation": "it is considered a good security practice to:10 u detect the presence of a jailbreak u refuse to install or run on a system which has been jailbroken below is a very simple example of a test for jailbroken devices (obviously to be successful, more sophisticated checks are required): bool isjailbroken() { #if target_iphone_simulator return no; #else file *f = fopen(\"/bin/bash\", \"r\"); if (errno == enoent) { // device is not jailbroken fclose(f); return no; } else { // device is jailbroken fclose(f); return yes; } #endif } affects: \"abc 123.ipa\" 10 owasp jailbreak cheatsheet https://www.owasp.org/index.php/mobile_jailbreaking_cheat_sheet",
  "affects": "ip address dns name port 192.1.1.121 testorg-client.co.uk 7083"
},
"sr-102-012" : {
  "identifier": "sr-102-012",
  "title": "ssl/tls renegotiation dos",
  "risk": "medium",
  "status": "open",
  "description": "the remote service encrypts traffic using tls/ssl but allows a client to renegotiate the connection after the initial handshake. an attacker could use this vulnerability to trigger renegotiation of existing ssl connections to cause a denial of service due to resource exhaustion on the server. publicly available dos tools could take advantage of the renegotiation to automate an attack against the server.",
  "recommendation": "disable renegotiation on the server-side completely",
  "affects": "ip address dns name port 192.1.1.121, testorg-client.co.uk, 7083"
},
"sr-102-014" : {
  "identifier": "sr-102-014",
  "title": "Backgrounding Screenshot Disabled",
  "risk": "Low",
  "status": "Open",
  "description": "By default, iOS takes a screenshot of the current UI when an application is sent to the background. If not disabled, sensitive data in screenshot could be written to the device file system.",
  "recommendation": "The application should prevent iOS from taking a snapshot of sensitive data when the background or suspended state is entered. This can be accomplished by setting window.hidden to yes in the applicationDidEnterBackground delegate and window.hidden to no in the applicationWillEnterForeground delegate.",
  "affects": "abc 123.ipa"
},
"sr-102-015" : {
  "identifier": "sr-102-015",
  "title": "manual screenshots not disabled",
  "risk": "low",
  "status": "open",
  "description": "it was possible for the user to take screen captures of the mobile application, using ios's screenshot key combination. this could lead to images containing sensitive information (such as recently accessed client information) being stored in unencrypted form on the device file system.",
  "recommendation": "there is no documented method to prevent manual screenshots being taken on ios at the time of writing, and hence this risk has to be accepted by clientname",
  "affects": "abc 123.ipa"
},
"sr-102-016" : {
  "identifier": "sr-102-016",
  "title": "No support for TLS versions above 1.0",
  "risk": "Low",
  "status": "Open",
  "description": " the affected server did not support tls above version 1.0. since 2008, tls has been at version 1.2, with version 1.3 being defined in august 2018. versions 1.2 and 1.3 of tls are more resistant to known attacks, and tlsv1.2 supports more modern cipher suites that are widely acknowledged to offer the best cryptography available for securing internet connections. tlsv1.3 further improves on security by removing unsafe or unused features, eliminating unnecessary handshake steps and forcing the use of newer encryption methods. it should be noted that use of tls 1.0 and 1.1 is now flagged as insecure (such as by browser warnings) by the major browsers, and in january 2021 the nsa issued guidance urging system administrators to only provide support for tls versions 1.2 or 1.3.15 tls 1.0 was the highest protocol version supported, as shown in supplemental data - sslscan output on page 30. recent versions of all web browsers support 1.2 and 1.3, and therefore supporting these protocols server-side offers better security for those clients using modern browsers. tlsv1.2 also supports a class of cipher suites that offer authenticated encryption with associated data (aead). these cipher suites include an authenticated integrity check within the encryption operation, and are resistant to more attacks than their older counterparts. google's chrome browser states that the security of connections to websites that do not use aead ciphers is \"obsolete\". currently, this is not presented as an error to the user, merely as information for anyone viewing the page's security report (in the browser's developer console). however, as google continues to push for the rapid adoption of more robust internet cryptography, this message may become more prominent. tlsv1.3 was approved for use in august 2018 and goes to further enhance security. the security benefits of tlsv1.3 include the removal of unsafe or unused features, elimination of unnecessary handshake steps and the forced use of newer encryption methods. as well as preventing encryption downgrade attacks, the streamlined approach to session initiation will offer performance gains over previous tls implementations. it should be noted that major browser vendors have stated that support for tlsv1.0 and 1.1 will be dropped in the near future. supporting tls 1.0 as a security control is non-compliant with the payment card industry (pci) data security standard (dss). while these regulations may not be directly relevant, it should be expected that this directive will become security best practice and may also be reflected in more obvious ways, such as web browser warnings. ",
  "recommendation": "add support for tls v1.2 and v1.3.16, 17, 18, 19, 20, 21, 22 support for tls version 1.0 should be disabled unless there is a specific business requirement to allow users of older, less secure browsers to continue to connect. consider also disabling support for version 1.1, which will become unsupported by major browsers in the near future. all affected hosts should be configured to prefer the latest cipher suites that they offer, such as aes-gcm (tls 1.2 and 1.3 only). the reference from mozilla below provides recommendations on cipher suite ordering based on the profile of connection 5 eliminating obsolete transport layer security (tls) protocol configurations - https://media.defense.gov/2021/jan/05/2002560140/-1/-1/0/elimi nating_obsolete_tls_uoo197443-20.pdf",
  "affects": "ip address dns name port 192.1.1.121 testorg-client.co.uk 7083"
}}
}
