{
  "testorg-samplewapt-001": "finding pre-authentication sql injection in dologin risk critical impact: high, exploitability: high identifier testorg-samplewapt-001 status reported category data validation component web application location the dologin function inacmeorders-git/v2/examplecorp.orders.orderutils/users/userrepo.cs. impact an attacker can compromise all data in the database, and can often compromise the underlying operating system. description sql injection is a class of attacks related to web application input and output validation. the flaw is found in situations where an end user can submit data to the application residing on the server, which then uses this data to dynamically generate and execute sql queries to a database (most commonly, via string concatenation). if the application fails to adequately limit the input a user can present to the application, it is possible for an attacker to take advantage of this to execute arbitrary sql statements. this will generally result in complete compromise of the data in the database, and can often result in compromise of the underlying operating system. generally, the 'acmeorders' backend api was architected to use stored procedures with parameter binding. this is a safe method of query construction that is not vulnerable to sql injection. however, in this instance, the application is generating a dynamic sql query by interpolating string values into the sql query. at line 835 of dologin, theusername parameter is interpolated into a sql statement, which is then executed. this is a string value that is entirely controlled by the user. by using specially chosen characters, an attacker can modify the query that is ultimately performed against the database in order to read or modify critical application data, bypass application logic, escalate privileges within the database, or use the database to access the filesystem or operating system functionality. note: similar instances of this issue are present in the modifycreds and storecreds functions. reproduction steps 1. send the following post http request to https://acmeorders.[examplecorpurl].com/home/validateme: post home/validateme http/1.1 host: acmeorders.[examplecorpurl].com user-agent: mozilla/5.0 (macintosh; intel mac os x 10.14; rv:68.0) gecko/2010 0101 firefox/68.0 accept: application/json, text/javascript, */*; q=0.01 accept-language: en-us,en;q=0.5 accept-encoding: gzip, deflate referer: https://acmeorders.[examplecorpurl].com/home/start content-type: application/x-www-form-urlencoded; charset=utf-8 x-requested-with: xmlhttprequest content-length: 91 sample dnt: 1 connection: close cookie: asp.net_sessionid=<sessionid> username=invalid@testorg.com' or 1=1--&password=foo 2. note that the user is now authenticated as the default 'orders' role. recommendation sql injection is best prevented by the use of parameterized queries (also called prepared statements), which define a sql query string and data elements separately. this prevents the user from entering data that could escape the original sql query to modify its functionality. as an additional benefit, execution of parameterized queries is often faster than that of dynamic sql queries. prepared statements should be used for all non-static queries, even those that do not directly take user input; dynamic data must not be interpolated into queries using string concatenation. the following code shows a safely constructed query: java.sql.preparedstatement safestatement = connection.preparedstatement( 'select * from products where prodname = ? and serialnumber = ?' ); safestatement.setstring(1, productname); safestatement.setint(2, serialnumber); safestatement.executequery(); for more advice on fixing sql injection, we recommend consulting the owasp sql injection prevention cheat sheet.",
  "testorg-samplewapt-002": "finding users can become other users via manipulated jwt risk critical impact: high, exploitability: high identifier testorg-samplewapt-002 status reported category data validation component web application location https://acmeorders.[examplecorp].com/api/token impact an attacker can create a valid jwt for any other user by sending a jwt containing a modified username to the https://acmeorders.[examplecorp].com/api/token endpoint. description the https://acmeorders.[examplecorp].com/api/token endpoint provides multiple code paths whereby users can exchange their access token for a new access token based on the perm_type parameter sent in the request. the validate, validate_token, and reload_token grant types call the validatetoken, validatetokenobj, and reloadtoken functions respectively. each of these functions call the 'loadtoken' function on the jwt access token provided by the user. the 'loadtoken' function does not validate the signature of the jwt token object returned by the function. as such, an attacker can set arbitrary values within the jwt that are then trusted by the application. using this ability, the attacker can change the username of the jwt to receive a new, signed jwt from the application that would allow the attacker to act as the user. reproduction steps 1. send the following post request body to https://acmeorders.[examplecorp].com/api/token: client_id=ao&client_secret=ao%314159&access_token=eyjhbgcioijiuzi1niisinr5cci 6ikpxvcj9cg.eyjzdwiioij0zxn0dxnlcjnabmnjz3jvdxauy29tiiwidgvuyw50ijoiqwntzs isinrlbmfudelkijoimsisinnhbgvzrm9ybwf0ijoimsisimfsbfrlbxbsyxrlcyi6ijeilcjh bgxbz2vudhmioiixiiwiijowotawodg4nswizxhwijoxnty5otk5otk5lcjpc3mioijby21lq2 9yccis.&grant_type=validate_token. 2. note: observe that the access_token parameter has an empty signature field. 3. send the above request and observe that a valid access_token and refresh_token are returned fortestuser3@testorg.com. 4. modify the contents of the above access_token to include any user within the sub field of the access_token. 5. resend the request and observe that a new access_token and refresh_token are returned for the new user. recommendation use the 'loadandverifytoken' function, instead of the 'loadtoken' to validate the access token using the certificate that the access token was signed with. additionally, validate the alg and any other pre-validation field match the expected algorithm or value of the received access token. finally, the oauth working group has developed a draft document outlining the json web token best current practices1 that examplecorp can use to better ensure their design conforms with the industry accepted best practices. 1 https://tools.ietf.org/html/draft-ietf-oauth-jwt-bcp-06",
  "testorg-samplewapt-014": "finding account takeover via sms password reset risk critical impact: high, exploitability: high identifier testorg-samplewapt-014 status new category authentication component api location https://acmeorders.[examplecorp].com/api/reset-pw-sms impact attackers can takeover a user account by sending a forged password reset request. once an attacker takes over an account, they can post new content, delete content, modify account settings, manage orders, and more. private information, such as private order information, phone numbers, location, and gender can be obtained by an attacker. description the endpoint at https://acmeorders.[examplecorp].com/api/reset-pw-sms does not verify if the _uid parameter is tied with the phone number and four-digit password reset code when a post request is sent to it. an attacker can request a sms password reset of their own account and have a four-digit code sent to their phone. after getting the code, they can submit the code to thereset-pw-sms endpoint and replace the_uid value with any_uid of their choice. this will allow the attacker to change the password for another users account. the_uid value of a specific user can be found by visiting the target user's profile and using a browser proxy to view the request sent to /profile/username/[_uid] (where [_uid] looks like a long string of random letters and numbers) to get the user's_uid. reproduction steps 1. create a test account on https://acmeorders.[examplecorp].com. 2. add a phone number to the test account by going to the profile page of the account. 3. save the phone number and logout. 4. at the login page, go to 'request password reset.' 5. enter the phone number from step 2 to receive a four-digit reset code by sms. 6. after receiving the code, use a web proxy such as burpsuite to intercept web requests from a browser. 7. enter the code on https://acmeorders.[examplecorp].com and intercept the request to https://acmeorders.[examplecorp].com/api/reset-pw-sms, which contains the four-digit code. 8. change the_uid parameter to the_uid of the victim account. the_uid value can be found by visiting a target user's profile and viewing, using a web proxy, a request to '/ profile/username/[_uid]' (where [_uid] looks like a long string of random letters and numbers) to get a user's_uid. 9. send the request and change the password for the target/victim account. recommendation ensure that thereset-pw-sms endpoint is properly handling requests, including: * perform basic validity checking, including checking any posted_uid parameter, phone number, and four-digit code are currently valid. * generate random (low predictability), unique codes to authorize password reset. * make sure four-digit codes expire after some reasonable length of time, and do not re-use codes. * verify that the phone number in the request is associated with the proper_uid and that the supplied code was sent to that phone number.",
  "testorg-samplewapt-003": "finding users can change arbitrary user's password via updatepassword risk high impact: high, exploitability: high identifier testorg-samplewapt-003 status new category access controls component web application location https://acmeorders.[examplecorpurl].com/api/user/updatepassword impact any acmeorders user can change the password of any other user. description the user/updatepassword api allows users to specify an arbitrary username and forcenewpassword parameter for the request. these values are passed to the updatepassword function in the userrepo class. the updatepassword function interpolates the values into a database query and stores them into the database. this allows an attacker to update or deny access to any user's account by directly invoking this endpoint. reproduction steps 1. authenticate to the acmeorders application and retrieve the access token returned to the user. 2. send the following request to https://acmeorders.[examplecorpurl].com, filling in the 'victim username' parameter with the name of a user you have credentials for and intend to reset the password of: post /api/v2/updatepassword http/1.1 host: acmeorders.[examploecorpurl].com user-agent: mozilla/5.0 (macintosh; intel mac os x 10.14; rv:68.0) gecko/2010 0101 firefox/68.0 accept: application/json accept-language: en-us,en;q=0.5 accept-encoding: gzip, deflate content-type: application/json authorization: bearer <access token here> connection: close referer: https://acmeorders.[examplecoropurl].com/dash cookie: lb.acmeorders.[examplecorpurl].com_pool=<value> {'username':'<victim username>', 'forcenewpassword':'testorg@1234'} 3. observe that it is now no longer possible to authenticate with the victim username and credentials. 4. additionally, by viewing the database directly, observe that the password for the victim user is now testorgp@1234. recommendation do not allow the user to submit a username parameter as part of a password change request; instead, retrieve the user'susername from their jwt oauth token. additionally, create separate endpoints for performing a password reset for a user with a forgotten password and for users updating their password using their prevpassword. this will allow the endpoint to validate the user's existing password to prevent attackers with access to a vulnerability, for example server-side request forgery, which allows the attacker to invoke this endpoint.",
  "testorg-samplewapt-004": "finding arbitrary file read in example files object risk high impact: high, exploitability: high identifier testorg-samplewapt-004 status reported category access controls component web application location the 'examplefilesobjectcontroller method located at acmeorders-git/v7/examplecorp.orders.businesslogic/ files/examplefile.cs:452' impact an attacker can read files from the server, including application source code and sensitive operating system files. this could enable the attacker to steal infrastructure credentials, perform denial-of-service attacks, dump user information, or find additional vulnerabilities in the application. description when accessing the filesystem, it is extremely important that an application performs security checking to ensure valid access. if a user-controlled filename is provided to the system, it opens a risk of file access that is not limited to the intended files. the application does not perform validation when returning files to the user from theexamplefilesobject controller. as a result, an attacker can read arbitrary files on the application server, including application source code and configuration files. inserting path characters (/ or ../) into the vulnerable parameter allows the attacker to traverse outside of the default directory to access sensitive files stored in system or application directories. for most methods in this controller, files are retrieved from a separate backend service. those backend services may be vulnerable to file access issues as well, but were not in scope for the engagement and so were not tested. however, at least one method in the examplefilesobject controller reads files from the local filesystem, as shown here: [httpget] public actionresult downloadsavedfile(string filename) { var ms = default(byte[]); var tmppath = path.gettemppath(); var filebytes = system.io.file.readallbytes(tmppath + filename); return file(filebytes, mediatypenames.application.zip, filename); ... the filename parameter is provided by the user. reproduction steps submit the following request to the application, substituting valid cookies: get /v2/examplefiles/savefile?fileids=1,2 http/1.1 host: apppreview.[examplecorpurl].com connection: close accept: application/json, text/javascript, */*; q=0.01 x-requested-with: xmlhttprequest user-agent: mozilla/5.0 (macintosh; intel mac os x 10_14_6) applewebkit/537.36 ( khtml, like gecko) chrome/77.0.3865.0 safari/537.36 sec-fetch-mode: cors content-type: application/json; charset=utf-8 sec-fetch-site: same-origin referer: https://apppreview.[examplecorpurl].com/examplefinder/index accept-encoding: gzip, deflate accept-language: en-us,en;q=0.9 cookie: bigipserver~[www.examplecorpurl].com_pool=5551212; asp.net_sessionid=blo bxvy5778rgqf2; shortdateformat=m/dd; longdateformat=mm/dd/yyyy; _ga=5551212; _gid=5551212; lzt=zulu; .aspxauth=a45666888bf7899etc after successfully submitting that request, submit the following request with valid cookies: get /v2/examplefiles/downloadsavedfile?filename=..\\..\\..\\..\\..\\..\\..\\..\\windows\\ system32\\drivers\\etc\\hosts http/1.1 host: apppreview.[examplecorpurl].com connection: close accept: application/json, text/javascript, */*; q=0.01 x-requested-with: xmlhttprequest user-agent: mozilla/5.0 (macintosh; intel mac os x 10_14_6) applewebkit/537.36 ( khtml, like gecko) chrome/77.0.3865.0 safari/537.36 sec-fetch-mode: cors content-type: application/json; charset=utf-8 sec-fetch-site: same-origin referer: https://apppreview.[examplecorpurl].com/examplefinder/index accept-encoding: gzip, deflate accept-language: en-us,en;q=0.9 cookie: bigipserver~[www.examplecorpurl].com_pool=5551212; asp.net_sessionid=exa mblebafy5778rgqf2; shortdateformat=m/dd; longdateformat=mm/dd/yyyy; _ga=5551 212; _gid=5551212; lzt=zulu; .aspxauth=example788943rrttu observe that the server responds with the contents of thewindows\\system32\\drivers\\e tc\\hosts file: http/1.1 200 ok cache-control: private content-type: application/zip server: microsoft-iis/8.5 x-aspnetmvc-version: 5.2 content-disposition: attachment; filename='..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\windo ws\\\\system32\\\\drivers\\\\etc\\\\hosts' # localhost name resolution is handled within dns itself. # 127.0.0.1 localhost # ::1 localhost # clientfileserver host entries 172.48.4.11 examplecorp01 examplecorp01.{examplednsname}.com ... recommendation if the multiple file zip download logic is not currently used in the application, then this can simply be removed from the application. from the web ui, it did not appear to be possible to exercise this logic, indicating that it is not currently used. otherwise, apply file access controls to prevent an attacker from performing attacks such as path traversal. access controls can encompass a number of different strategies: * whitelisting of allowed files for writing and reading * input sanitization to strip filenames of dangerous characters * ignoring user-controlled filenames and storing files using a randomly generated filename in a safe directory these strategies must be applied in addition to normal application protections, such as authorization checking for file access, preventing access to restricted files, and storing uploaded files outside of the application's root.",
  "testorg-samplewapt-007": "finding design pattern creates risk of server-side request forgery (ssrf) risk high impact: high, exploitability: undetermined identifier testorg-samplewapt-007 status reported category data exposure component web application impact the design patterns used in the acmeorders web application's source code create a significant risk of ssrf vulnerabilities. using an ssrf vulnerability, an attacker could port scan and fetch web content from the application's internal network and from services listening locally on the application server. it could also be possible to exfiltrate sensitive information or exploit insecure services that are only exposed internally. description in a server-side request forgery (ssrf) attack, the attacker abuses functionality on the server to read or modify resources internal to the application's network infrastructure. the attacker can supply or modify a url that the code running on the server will fetch or submit data to.2 acmeorder's architecture and source code design patterns create a significant risk of ssrf vulnerabilities. specifically, the acmeorders web application creates http requests to other services on examplecorp's network using user-supplied parameters. if the user-supplied data can be used to change the intended destination of the request, ssrf attacks could result. the acmeorders web application performs a backend http request for almost every nonstatic user request. these requests primarily go to the internal acmeorders api. for example, when retrieving details on a specified order, the following method ofexamplecontroller.cs is called: [httpget] public actionresult exampleoverview(int exampleid) { var client = new apiclienthandler(session['accesstoken'].tostring()); var apiurl = $'{configurationmanager.appsettings[' api_urlbase']}/examples/{e xampleid}'; var examples = client.getasyncwithautotokenrefresh<example>(this, apiurl); ... this method concatenates the user-suppliedexampleid parameter into a urlapiurl, which is then requested via the methodgetasyncwithautotokenrefresh. this is a pattern that has a significant risk for ssrf vulnerabilities. in this case, becauseexampleid is parsed as an integer, there is little risk. but in other methods, if a string parameter is provided, an attacker could potentially control the url of the request to change the destination host or to change the specific route on the host. there are other locations where this pattern occurs using user-supplied string parameters, such as theregistration parameter in the following method ofexamplereportcontroll er.cs: 2 wallarm's ssrf bible(pdf) provides a thorough introduction to ssrf vulnerabilities and exploitation. public actionresult exportdata(datetime begindate, datetime enddate, string regi stration, string examplenumber, string customercode, string exampledepstn, [datasourcerequest] datasourcerequest request) { if (session['accesstoken'] == null) return redirect('~/home/authorization'); var client = new apiclienthandler(session['accesstoken'].tostring()); var getallurlstring = $ '{configurationmanager.appsettings[' api_urlbase']}/' + $'examplereport?begindate={begindate}&enddate={enddate}&' + $'registration={registration}&examplenumber={examplenumber}&' + $'customercode={customercode}&exampledepstn={exampledepstn}'; test organization did not attempt to identify all locations where this pattern occurs, as the pattern is systemic across the acmeorders web application. there are a number of possible ways to exploit the issue: * changing the destination host from the expected host (e.g. the internal acmeorders api) to another backend system * changing the requested route (e.g./examplereport) to a different route on the same host, such as/user/changepassword * adding or modifying request parameters that are not otherwise user-controlled the actual exploitability of the issue has not been explored, as an exploit would depend on a number of complex factors: the context of the vulnerability itself, the code logic that handles url parsing,3 and the logic and routing of the targeted system. recommendation first, all user-supplied parameters should undergo url encoding before being included in url strings. this appears to be the primary issue within the acmeorders codebase. by forcing url encoding on user-supplied parameters, those parameters will not be able to break the application's url parsing logic or add additional parameters. .net provides the httputility.urlencode method for this purpose. additional information can be found on wikipedia. there are a number of additional strategies that could help to mitigate this design flaw. network traffic controls could be used to whitelist routes from the acmeorders web application to the internal api and prevent outbound http requests to other servers; however, the web application talks to other hosts as well, and all whitelisted hosts would still be vulnerable to attacks. another strategy would be to perform parameter validation on all user-supplied parameters in the user-facing web application. the validation of id types (must be an integer) provides an example of this. if there are known formats for other fields (in particular, all string fields that are supplied by users), those could be validated to ensure they match a safe character set. for most purposes in acmeorders, test organization believes that whitelisting the character set [a-za-z0-9_\\-] (letters, digits, underscores, and hyphens) would prevent exploitation of most vulnerabilities without overly restricting input. however, this character set may not suffice for all purposes (such as email addresses), and so it would not necessarily be possible to apply it universally. 3 see orange tsai's talka new era of ssrf: exploiting url parser in trending programming languages(pdf)",
  "testorg-samplewapt-011": "finding application returns incorrect content-type for json responses risk high impact: high, exploitability: high identifier testorg-samplewapt-011 status new category data validation component web application location the json responses for xmlhttprequest requests performed by acmeorders, such as: * https://[acmeorder_uri]/dir1/get_orders * https://[acmeorder_uri]/dir1/get_invoices * https://[acmeorder_uri]/dir1/foo.json * etc. * etc. impact browsers may behave unexpectedly when presented with an incorrectcontent-type. since acmeorders is returning json content with a content-type of text/html, the application is vulnerable to cross-site scripting attacks. description web browsers rely on the httpcontent-type header to determine how to handle responses from web applications, whether that content is html, javascript, an image, or something else. if an application returns an invalid or incorrect content-type, browsers will still attempt to parse the response, but often behave unexpectedly or insecurely. the acmeorders application returns json responses containing user-controller information, but with an html content-type: http/1.1 200 ok server: tornadoserver/6.0.3 content-type: text/html {'draw':4,'recordstotal':94050,'recordsfiltered':1,'data':[['testorg-grouptest@[examplecorptest].com','a test group','member']]} upon receiving this response, a web browser will skip past all preliminary characters and begin parsing once it reaches an html tag. a malicious user could change their group description in order to cause cross-site scripting: http/1.1 200 ok server: tornadoserver/6.0.3 content-type: text/html {'draw':4,'recordstotal':94050,'recordsfiltered':1,'data':[['testorg-grouptest@[examplecorptest].com','a test group<script>alert(1)</script>','member' ]]} applications must always set the correctcontent-type for responses. any invalid or incorrect content-type could potentially be exploited. recommendation for every response containing a message body, the web application should include a single content-type header that correctly and unambiguously states themime typeof the content in the response body. acmeorders should ensure that all json responses have a content-type of application/json. tornado's requesthandler.write() will do this automatically if the supplied argument is a dictionary (dict); however, acmeorders instead passeswrite() a string (str) by callingjson.dumps(). applications that serve uploaded files should additionally set the following headers to prevent content-type confusion on user-uploaded content: * x-content-type-options: nosniff: instructs browsers not to guess at the contenttype * content-disposition: attachment: instructs the browser to download the file rather than render it",
  "testorg-samplewapt-013": "finding s3 buckets misconfigured risk high impact: high, exploitability: high identifier testorg-samplewapt-013 status new category access controls component aws location note: this finding results from an optional service focused on cloud security review; while not typically a part of a standard web application security assessment, we commonly identify cloud-related issues like this for applications hosted on platforms such as aws, azure, and google cloud platform. the following s3 buckets in examplecorp's aws environment. * examplecorp-sitemaps * examplecorp-demo * examplecorp-orders * examplecorp-invoices * examplecorp-test * examplecorp-chipper * examplecorp-builds impact for components of acmeorders that utilize s3 buckets for storage, an attacker may do the following: * enumerate the contents of the buckets whose acls grant read (list) permission to the 'authenticated users' group or anonymous users. * upload new files and use examplecorp's bucket to host and distribute malware. * gain information about the access controls in place for the target buckets and mount further attacks using this information. * access objects in buckets that are not granted the read (list) permission for anonymous users. description test organization identified the following misconfigurations in examplecorp's s3 buckets. * the examplecorp-sitemaps bucket is world-readable (listable) for anonymous users. * the examplecorp-demo bucket is world-writable for anonymous users. additionally, it was discovered that the following buckets have a policy to allow any aws principle to perform get actions on the objects that reside within the buckets. this effectively makes all objects in the bucket readable. * examplecorp-orders * examplecorp-invoices * examplecorp-test * examplecorp-chipper * examplecorp-builds { 'action': [ 's3:getobject' ], 'effect': 'allow', 'principal': '*', 'resource': 'arn:aws:s3:::[bucket-name]/*' 'sid': 'addperm' } although test organization was not able to examine each exposed object, due to the time restricted nature of the engagement, several buckets seem to contain sensitive information. for example, objects in theexamplecorp-invoices bucket include erb (embedded ruby) templates, pdfs, and images. objects in theexamplecorp-builds bucket include client-side source code used by the web application. it should be noted that at the time of the engagement no malicious items were found in the examplecorp-demo bucket. reproduction steps 1. examine the bucket acls for the target buckets. the only permission grants for the given bucket are for the userzack. aws s3api get-bucket-acl --bucket examplecorp-orders { 'owner': { 'displayname': 'zack', 'id': '820a4f[idstring..................]64' }, 'grants': [ { 'grantee': { 'displayname': 'zack', 'id': '820a4f[idstring..................]64', 'type': 'canonicaluser' }, 'permission': 'full_control' } ] } 2. navigate to: https://[examplecorp-ordersurl].s3.amazonaws.com/dir1/documents/dir2/dir3/order_template.html.erb 3. note that you have just accessed the erb template used by the acmeorders web application. recommendation ensure that the iam policies, s3 bucket policies, and s3 access control lists (acls) limit the access of the s3 bucket to those who have a defined business need. if an s3 bucket is no longer needed, it should be deleted.",
  "testorg-samplewapt-006": "finding application uses weak hash to store passwords risk medium impact: medium, exploitability: medium identifier testorg-samplewapt-006 status reported category cryptography component web application location the authentication logic defined inexampleorder-git/v7/example.path.businesslogic/ users/exampleuser.cs:235-258. impact an attacker who is able to compromise the application's storage, such as through a database flaw or information disclosure, can more easily recover user passwords. description the application stores user passwords for accounts using two password hashing schemes, with varying weaknesses. test organization traced the flow of authentication logic through the application and found the following method: examplebranch::authenticateuser() - logic to authenticate user against local database, and to choose between two password hashes * oldexampleencryption::checkpassword() - legacy password check, usesbcrypt with a static salt * securityexamplelibrary::diffexamplepasswords() - current password check, uses sha512 (single round) with a unique salt bcrypt is a safe, widely-supported password hash. however, the underlying implementation uses a static salt (line 721 ofoldexampleencryption.cs). a salt is a random per-password value that slows down cracking attempts by requiring attackers to perform a new bruteforce attack on each password. for example, with unique salts, two users with the password '123456' would have different password hashes. with a static salt, an attacker with access to hashed passwords would not need to attempt to crack each password individually. instead, a brute-force attack would enable them to attack all password hashes concurrently without any extra work. in comparison, thediffexamplepasswords does use a unique salt for each password. however, sha512 is not an effective hash for password hashing. because this hash can be performed very quickly, hashed passwords are vulnerable to brute-force cracking. an attacker with access to the hashed passwords is likely to be able to recover significant numbers of plaintext passwords using a tool such ashashcat. an ideal password hash forces an attack to use significant resources to crack dumped password hashes. additionally, the presence of two separate hashing schemes (one named 'old') suggests that a migration was never finalized. when switching to a new hashing scheme, it is best to create a defined process and a timeline for the complete switchover to be performed so that legacy logic may be removed in an explicit timeframe. this way, vulnerabilities in outdated code do not affect the application after the code is no longer in use. recommendation test organization recommends usingbcrypt, a widely-supported hash that handles salting automatically. this hashing algorithm is designed to resist brute-forcing attempts. the only aspect of bcrypt that requires manual configuration is the 'cost factor', a value which determines how many iterations to perform4 (thus determining the amount of processing time necessary to hash a single password). test organization recommends that most applications use a cost factor of 12. on modern processors, this cost factor results in hashing taking approximately half a second for each password.5 the existing bcrypt implementation has a number of issues and should not be used going forward. instead, use a library with a safe api such as https://github.com/bcryptnet/bcrypt.net. this library handles salting internally and a salt should not be supplied to the library calls. to upgrade to a modern password hash, there are a number of possible strategies: * discard all existing hashes and force users to set new passwords. this strategy may work well for applications with a small number of users who can be reached directly, such as internal company applications. * upgrade users at their next login by comparing the existing hash, saving the new hash, and finally discarding the existing hash. this strategy is effective for active users, but can have issues with users who do not log in for long periods of time: their old, weak password hashes will remain in the database until they log in. * immediately upgrading all hashes by using the new hashing algorithm on the existing hashed passwords. when users log in, first hash their password with the legacy algorithm, then hash again with the modern algorithm. this strategy is safe in most cases (even for weak algorithms like md5), but requires the application to maintain the backwards-compatibility logic indefinitely. 4 see https://security.stackexchange.com/a/3993 for a more in-depth explanation of work factors for password hashing. 5 see https://security.stackexchange.com/a/83382 for a benchmark of bcrypt on a recent intel processor.",
  "testorg-samplewapt-012": "finding iam passrole permission allows potential authorization bypass risk medium impact: high, exploitability: low identifier testorg-samplewapt-012 status new category access controls component aws location note: this finding results from an optional service focused on cloud security review; while not typically a part of a standard web application security assessment, we commonly identify cloud-related issues like this for applications hosted on platforms such as aws, azure, and google cloud platform. the following iam policies in examplecorp's aws environment: * aws-codepipeline-service * cloudformationlambdaexecuteroll * awslambdafullaccess * autoscalingservicerolepolicy * awsdatapipelinerole * teamcityserver * awsec2spotservicerolepolicy * lambdafunctiondeploy impact an iam user in the groups above may be able to achieve privilege escalation to access resources or services without authorization. description some acmeorders application instances are hosted on aws. when configuring or creating an instance of an aws service, users generally pass on an iam role to that service. when the service needs to perform a privileged aws task, it can then use the permissions associated with its iam role (and the automatically-provisioned aws credentials) to perform the action. the aws permissioniam:passrole6 is what defines which roles an iam user (or a service itself) can pass on. the groups listed in the location section above have the following permissions statement (edited for brevity). 'action': [ ... 'iam:passrole', ... ], 'effect': 'allow', 'resource': [ '*' ] this statement allows a user to passany role to a new service, even one the user does not have. this ability is somewhat restricted; for example, the requested role may only be valid for certain services (defined as the 'trusted entities' via the 'sts:assumerole' permission on the role). additionally, to pass a role to an ec2 instance, there must be an instance profile for the given role. the effect of this statement is that a user in the target groups may be able to pass a role that has privileges the user themselves does not. for example, a user, such asmichael, who 6 https://docs.aws.amazon.com/iam/latest/userguide/id_roles_use_passrole.html would normally have read-only access to s3 buckets but is also a member ofamazonkinesisf irehosefullaccess, amazonredshiftfullaccess, amazons3fullaccess, orawslambda-fullaccess policies could pass themselves a role that would allow them full access to all aws resources. as a result, the expected permissions model may be violated, allowing users to access many services or resources outside of their expected abilities. recommendation when granting theiam:passrole permission, the 'resource' should always be limited to only the intended role for the given user. amazon's aws documentation provides a tutorial with a number of examples at https://aws.amazon.com/blogs/security/granting-permission-to-launch-ec2-instances-with-iam-roles-passrole-permission/",
  "testorg-samplewapt-008": "finding verbose error messages disclose sensitive information risk low impact: low, exploitability: medium identifier testorg-samplewapt-008 status reported category data exposure component web application location the customerrors setting defined inweb.config:116 impact the application discloses application stack traces when an unhandled error occurs. an attacker may be able to use this information to aid further attacks or as part of a social engineering attack. description when an error condition occurs in acmeorders, the response includes a full application stack trace. a user can trigger an error condition by sending invalid input in a number of locations. specifically, the error page included: * full file paths of source code files * class names, method names and arguments, and line within source code file reproduction steps trigger a 500 error and observe that a detailed stack trace is included in the html body and also within an html comment. for example, navigate to https://exampleorder.[examplec orpurl].com/examplealert/getemailalertdetail?emailalertid=100 and observe the following stack trace: [httprequestexception: response status code does not indicate success: 500 (inte rnal server error).] [aggregateexception: one or more errors occurred.] system.threading.tasks.task`1.getresultcore(boolean waitcompletionnotificatio n) +589907 examplepath.v2.utilities.api`1.getrequest(string url, string token) in c:\\code\\examplepath\\v2\\utilities\\api.cs:22 examplepath.v2.utilities.api`1.getapidata(httpcontext currentcontext, string url, string recache) in c:\\code\\examplepath\\utilities\\api.cs:123 examplepath.v2.example.getemailalertdetail(jsondynamicwrapper json) in... [9 more similar references] recommendation the application should trap all errors and present a generic error message to the user. error details should be logged in the back end to a location not accessible from the external network. in .net mvc, thecustomerrors configuration attribute can bet set toon to display a generic error message when an unhandled exception occurs. microsoft provides documentation at https://msdn.microsoft.com/en-us/data/h0hfz6fc(v=vs.110).",
  "testorg-samplewapt-010": "finding potential backdoor user risk low impact: medium, exploitability: low identifier testorg-samplewapt-010 status reported category authentication component web application location the authentication logic defined inacmeorders-git/v7/example.path.businesslogic/ users/exampleuser.cs:512-515. impact an attacker with access to the application's source code or other internal knowledge of the acmeorders application may be able to use theexampleapiuser account to authenticate to the application without proper credentials. additionally, a malicious user may be able to use this account to access the application after their application access has been removed. description the authentication application logic contains two conditional statements checking for a example api user account using a hardcoded password. it appears that this conditional bypasses the normal application authentication flow. backdoor users that circumvent application logic make it difficult to restrict access to the application after a user's access is removed. additionally, if an attacker is able to recover the source code for the application without a valid set of credentials the attacker can potentially authenticate to the application using these backdoor credentials. below is a portion of the conditional that checks for theexampleapiuser: 512 if (userlogin.username == 'exampleapiuser' && userlogin.password == 'hardcoded_p assword_value') 513 { 514 user = new user { id = -1, displayname = 'exampleapiuser' }; 515 } reproduction steps navigate to https://url.[examplecorpurl].com/login/and provide 'exampleapiuser' and 'hard coded_password_value' as credentials. authentication succeeds and the user context is set as shown in the following screenshot: {example screenshot} recommendation remove this conditional statement from the application authentication logic. if acmeorders requires service accounts for performing application functionality, examplecorp should create a limited service account role, register the accounts with the application, and store their credentials in a secure secret storage mechanism such as aws secrets manager, hashicorp vault, or cyberark. 7 https://aws.amazon.com/secrets-manager/ 8 https://www.vaultproject.io 9 https://www.cyberark.com/products/privileged-account-security-solution/enterprise-password-vault/",
  "testorg-samplewapt-009": "finding multiple complex authentication methods risk informational impact: undetermined, exploitability: undetermined identifier testorg-samplewapt-009 status reported category authentication component web application impact the risk for authentication vulnerabilities is greatly increased due to the complexity introduced by the varied authentication sources, authentication tokens, and credential storage. description the acmeorders application uses a combination of active directory, application credentials, .net session management, and jwt-based oauth tokens for authentication. additionally, user credentials are currently stored in two locations: the acmeorders database exampleusers table and the exampleblob database exampleusers table. this varied collection of authentication sources, representation, and storage has caused the acmeorders authentication logic to be spread across various parts of the code base. in most locations where authentication logic is implemented, the logic is complex and includes a substantial amount of control flow. in particular, the main acmeorders authentication entry point,exampleuser.authenticateexampleuser, contains about 220 lines of code including a series of deeply nested control flow statements. this complexity and decentralization of the authentication logic contributed to the many authentication related vulnerabilities identified by test organization during testing. recommendation transition from the combination of active directory and application-based authentication sources to a single standardized authentication solution for both examplecorp employees and acmeorders application users. additionally, examplecorp should standardize the authentication token between all examplecorp services. examplecorp should centralize all authentication logic into a single portion of the codebase, ideally in the internal apis to allow easy reuse of the authentication logic. optimally, examplecorp should migrate all authentication to an external single-sign on (sso) provider to limit the necessity of managing user credentials. migrating to an sso provider would allow examplecorp to simplify the acmeorders authentication logic, improve customer credential management, easily implement security measures like multi-factor authentication, and reduce the difficulty of integrating with a customer's sign on solution if requested."
}